1. Pan Roman dobrze kojarzy, że czasami nie zachodzą podstawowe prawa, nie o to jednak chodzi tym razem. Błąd wynika z użycia is i błędnego założenia, że działa tak samo jak ==. Korzystając z == program sprawdzi nam czy wartości obu operand są równe, natomiast is sprawdzi nam czy obie operandy odnoszą się do dokładnie tego samego obiektu, co w przypadku programu pana Romana nie będzie zawsze prawdziwe. Python odpowiednio małe liczby całkowite (występują często), z braku lepszego określenia, alokuje do obiektów dla lepszej wydajności. (z ang. integer caching). Dlatego program Romana czasem działa - dla odpowiednio małych zmiennych a*b i b*a rzeczywiście odnoszą się do tego samego obiektu. Dla większych liczb jednak już to nie zachodzi.

2. Przykładowo ułamki 0.1 oraz 0.2 nie mogą zostać przedstawione w systemie binarnym na skończonej liczbie bitów i komputer musi je gdzieś zaokrąglić. Stąd wynika błąd reprezentacji. Wpisując w Pythonie 0.1+0.2==0.3 Otrzymamy False, gdyż 0.1+0.2 == 0.30000000000000004